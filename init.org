#+TITLE: Emacs Configuratione
#+OPTIONS: toc:4
#+PROPERTY: header-args:emacs-lisp :tangle yes :results silent :export code

* Introduction
This is my emacs configuration.  It is meant to be used across linux, windows, and BSD.  I use windows only at work (Industrial Controls).  I use emacs often as an advanced programmable calculator.

Lots of inspiration taken from:
- [[https://depp.brause.cc/dotemacs/][depp.brause.cc/dotemacs/]]
- [[https://github.com/larstvei/dot-emacs][github.com/larstvei/dot-emacs]]
- [[https://github.com/sachac/.emacs.d][github.com/sachac/.emacs.d]]

** A note on version checking
I keep my emacs installs at the latest release, so I don't worry about checking for versions in my init unless I happen to update on linux/BSD before the windows binaries are released.  That being said, I am currently on version 29.1.
** Latinization
I believe that all scientific knowledge, and by extension computational knowledge, should be shared in Latin.  That is to say I intend to facilitate Latin's return as the default language for global knowledge sharing.  To be consistent, I will soon be translating as much of this file as possible into Latin.  Monitus es.
* Meta Configuration
I have taken this mostly whole-hog from [[https://github.com/larstvei/dot-emacs][github.com/larstvei/dot-emacs]].  The idea is that this bare-bones init.el is available when the repo is pulled in, but gets overwritten on emacs' first run.  Emacs will need to be re-started after that initial run, since =early-init.el= will be created, and some packages will be installed.

This is the repo's =init.el= file, which bootstraps the real =init.el=.
#+BEGIN_SRC emacs-lisp :tangle no
;;; This file replaces itself with the real config at first run
;; We Can't tangle without org!
(require 'org)
;; Open the config...
(find-file (concat user-emacs-directory "init.org"))
;; Tangle it...
(org-babel-tangle)
;; Load it.
(load-file (concat user-emacs-directory "early-init.el"))
(load-file (concat user-emacs-directory "init.el"))
#+END_SRC

There is no reason to track the =init.el= that is generated.  Run the following command to make git ignore the generated file, but keep the dummy init.

#+BEGIN_SRC sh :tangle no
git update-index --assume-unchanged init.el
#+END_SRC

If changes to the dummy-init are needed, track those by running

#+BEGIN_SRC sh :tangle no
git update-index --no-assume-unchanged init.el
#+END_SRC

* Early init
This file was introduced in Emacs 27.  I use it for speeding up init, removing all the UI stuff I don't want, etc.  Maybe superfluous, but I do get startup times on the order of /0.015/ seconds.

** The normal header
There are no GNU Police (yet), but I feel nicer by adding this in.
#+BEGIN_SRC emacs-lisp :tangle ./early-init.el
;;; early-init.el -*- lexical-binding: t; -*-

;; Haec pars Emacs non est.

;; Code:
#+END_SRC

** GC thrashing
Set the GC threshold to max during startup, then set it back to a value that is somewhat more sane than the default /800kb/.

#+BEGIN_SRC emacs-lisp :tangle ./early-init.el
(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 0.6)

(add-hook 'after-init-hook #'(lambda () (setq gc-cons-threshold (* 1024 1024 25)
					 gc-cons-percentage 0.1)))
#+END_SRC

** Basic UI preferences
I want no menus, no tool-bars, no scroll-bars, no blinking cursor, and no messages when starting up.  I just want the scratch buffer with a report on =emacs-init-time=.  Make resizing work properly as well.

#+BEGIN_SRC emacs-lisp :tangle ./early-init.el
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(blink-cursor-mode -1)

(setq inhibit-startup-screen t
      inhibit-startup-buffer-menu t
      initial-scratch-message (message ";;; Emacs loaded in %s.\n\n" (emacs-init-time))
      server-client-instructions nil
      frame-resize-pixelwise t)
#+END_SRC

I am no longer using the default theme, so that config is no longer here, but [[*eink-emacs][here]].  Make every frame open full-screen, and re-emphasize the desire for no scroll-bars.

#+BEGIN_SRC emacs-lisp :tangle ./early-init.el
(setq default-frame-alist '((fullscreen . maximized)
			    (vertical-scroll-bars . nil)))
#+END_SRC

** Misc/odd issues
Avoid a weird issue on windows where opening emacs via an [[https://www.autohotkey.com/][AutoHotKey]] binding causes emacs to load in the AutoHotKey directory.

#+BEGIN_SRC emacs-lisp :tangle ./early-init.el
(setq default-directory "~/")
#+END_SRC

** The normal footer

#+BEGIN_SRC emacs-lisp :tangle ./early-init.el
(provide 'early-init)
;;; hic terminatur early-init.el
#+END_SRC

* Main init
** Header

#+BEGIN_SRC emacs-lisp
;;; init.el --- Quae configurare  -*- lexical-binding: t; -*-

;; Haec pars Emacs non est.

;; Code:
#+END_SRC

** Packages
Load packages first, so there is no question about dependencies later in the file.
*** Package Repositories
Non-gnu is in the defaults now, so I only need to add melpa.

#+BEGIN_SRC emacs-lisp
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
#+END_SRC

*** Packages I don't want on my work computers
I don't need these on a windows PC.
#+BEGIN_SRC emacs-lisp
(unless (equal system-type 'windows-nt)
  (use-package slime :ensure t)
  (use-package ledger-mode
    :ensure t
    :bind
  ((:map ledger-mode-map ("C-c s" . ledger-sort-buffer)))))
#+END_SRC

*** eink-emacs
I want a minimal (mostly b+w) theme.
#+BEGIN_SRC emacs-lisp
(use-package eink-theme
  :ensure t
  :init
  (load-theme 'eink t))
#+END_SRC
*** visual-fill-column
A godsend.  Finally, I can have visual-line-mode without having to read lines that are 1980 pixels wide!  Also set word wrap, and make the split for help do what I want on big screens.

#+BEGIN_SRC emacs-lisp
(use-package visual-fill-column
  :ensure t
  :custom
  (word-wrap t)
  (visual-fill-column-enable-sensible-window-split t)
  :config
  (global-visual-line-mode t))
#+END_SRC

Also make a defun/binding to toggle it as needed.
#+BEGIN_SRC emacs-lisp
(defun toggle-visual-fill-column-mode ()
"Toggles `visual-fill-column-mode."
  (interactive)
  (visual-fill-column-mode 'toggle))

(keymap-global-set "C-c v" 'toggle-visual-fill-column-mode)

#+END_SRC

*** corfu
I used =company-mode= for a long time.  I tried corfu and haven't looked back.  It is smaller, and does everything I was doing with company.

**** Main Corfu
The basics for corfu.  Auto popup after one letter, enable globally.

#+BEGIN_SRC emacs-lisp
(use-package corfu
  :ensure t
  :custom
  (corfu-auto t)
  (corfu-auto-delay 0)
  (corfu-auto-prefix 1)
  :config
  (global-corfu-mode))
#+END_SRC

**** corfu-popupinfo
This comes with base corfu, but is configured separately.

#+BEGIN_SRC emacs-lisp
(use-package corfu-popupinfo
  :ensure nil ; Part of corfu
  :after corfu
  :hook (corfu-mode . corfu-popupinfo-mode)
  :custom
  (corfu-popupinfo-delay '(nil . 0.01))
  (corfu-popupinfo-hide nil)
  :config
  (corfu-popupinfo-mode)
  :bind
  ((:map corfu-map ("C-h" . corfu-popupinfo-toggle))))
#+END_SRC

*** expand-region
Seldom used, but nothing else does it.

#+BEGIN_SRC emacs-lisp
(use-package expand-region :ensure t)
(keymap-global-set "C-=" 'er/expand-region)
#+END_SRC

*** magit
I use magit occasionally.  I put this sparse configuration here mostly for a speed boost, by making magit only load when I explicitly call for it.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :config
  (message "Magit Loaded")
  :bind
  ((:map ctl-x-map ("g" . magit-status))))
#+END_SRC

*** openwith
I need to open binary files with their own editor.  Disgusting.

#+BEGIN_SRC emacs-lisp
(use-package openwith
  :ensure t
  :config
  (openwith-mode t))

(setq openwith-associations (list
			     (list (openwith-make-extension-regexp
				    '("xls" "xlsx" "doc" "docx"
				      "ppt" "odt" "ods" "odg" "odp"))
				   "LibreOffice"
				   '(file))
			     (list (openwith-make-extension-regexp
				    '("adpro"))
				   "ProductivitySuite"
				   '(file))))
#+END_SRC

*** org-transclusion
Awesome package - adds transclusions, don't know how similar to Xanadu it is, but sounds basically the same.

#+BEGIN_SRC emacs-lisp
(use-package org-transclusion
  :ensure t
  :bind (("<f12>" . org-transclusion-add)
	 ("C-c n t" . org-transclusion-mode)))
#+END_SRC

*** acme-mouse
Not a package in the strict sense, just a .el file - pulled from [[https://github.com/akrito/acme-mouse/]] and modified to meet changes to the old =cl= package.
#+BEGIN_SRC emacs-lisp
(load (concat user-emacs-directory "acme-mouse.el"))
#+END_SRC

*** AUCTeX
Starting to do some work with LaTeX, surprised this is not in base, but org is.
#+BEGIN_SRC emacs-lisp
(use-package auctex
  :ensure t
  :defer t)
#+END_SRC

** Non-Package customization
This section has '/base/' emacs customization.  All the general stuff.

I so far have kept most of my setq declarations in one place, only recently splitting them into multiple declarations from one large one.

*** Defaults
I want these things every time, or at least setting them this way worked when a regular =setq= didn't.

#+BEGIN_SRC emacs-lisp
(setq-default indicate-empty-lines t
	      fill-column 80
	      cursor-type 'bar
	      cursor-in-non-selected-windows 'hollow)
#+END_SRC

*** Backup/Autosave
I originally had some autosave items in here, but the defaults appeared to be doing basically what I wanted anyway.

**** Backups
Make backups for vc-controlled files, don't clobber symlinks, and put everything into =~/emacs-backups/=.

#+BEGIN_SRC emacs-lisp
(setq vc-make-backup-files t
      backup-by-copying t
      backup-directory-alist `((".*" . "~/emacs-backups/")))
#+END_SRC

**** Old versions
Keep 10 versions, 5 'old' and 5 'new'.  Delete anything older.

#+BEGIN_SRC emacs-lisp
(setq delete-old-versions t
      kept-new-versions 5
      kept-old-versions 5)
#+END_SRC

*** File handling
I want to avoid ever seeing an error about missing newlines at the end of a file.

#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
#+END_SRC

When files change on disk, and there are no changes in the open buffer, revert to the on-disk version.
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
#+END_SRC

These are directly from [[https://depp.brause.cc/dotemacs/][depp.brause.cc/dotemacs/]]. They are intended to make Emacs drop changes and die when a segfault happens, rather than attempt to save potentially corrupted data.

#+BEGIN_SRC emacs-lisp
(setq attempt-stack-overflow-recovery nil
      attempt-orderly-shutdown-on-fatal-signal nil)
#+END_SRC

I want to strip all trailing whitespace on save, and I want to make all shell scripts executable at the same time.
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'whitespace-cleanup)
(add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

*** Minibuffer interaction
I don't want emacs to beep or blink at me, I want y/n instead of the default yes/no, I don't care for clicking on things in the minibuffer, I like seeing my commands echoed almost immediately, I want history to only show me unique commands, and I want case-insensitive buffer switching.

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore
      use-short-answers t
      use-file-dialog nil
      echo-keystrokes 0.1
      read-buffer-completion-ignore-case t
      history-delete-duplicates t)
#+END_SRC

*** Buffer interaction
**** General
Close unused buffers after 3 days.
#+BEGIN_SRC emacs-lisp
(midnight-mode t)
#+END_SRC

Overwrite selection when active, like every other editor since Sam.
#+BEGIN_SRC emacs-lisp
(delete-selection-mode t)
#+END_SRC

Don't disable any functions.
#+BEGIN_SRC emacs-lisp
(setq  disabled-command-function nil)
#+END_SRC

Save pastes from elsewhere into the kill-ring, and don't ask me about killing processes when I kill a buffer.
#+BEGIN_SRC emacs-lisp
(setq save-interprogram-paste-before-kill t
      confirm-kill-processes nil)
#+END_SRC

**** Scrolling
#+BEGIN_SRC emacs-lisp
(setq scroll-preserve-screen-position t)
#+END_SRC

**** Windmove
I originally had custom defuns and bindings to do this, but then I found out it was built in...

#+BEGIN_SRC emacs-lisp
(windmove-default-keybindings 'control)
(setq windmove-wrap-around t
      windmove-create-window t)
#+END_SRC

*** Buffer looks
Highlight current line in all buffers, even if inactive.
#+BEGIN_SRC emacs-lisp
(setq global-hl-line-sticky-flag t)
(global-hl-line-mode t)
#+END_SRC

I want nice symbols to look at
#+BEGIN_SRC emacs-lisp
(setq prettify-symbols-alist '(("lambda" . 955)
			       ("delta" . 120517)
			       ("epsilon" . 120518)
			       ("->" . 8594)
			       ("<=" . 8804)
			       (">=" . 8805)))
(global-prettify-symbols-mode t)
#+END_SRC

*** Parens
When I'm on a beginning/ending paren, I find the default of only highlighting the parens too hard to see, and highlighting the whole thing too garish.  Therefore, this setup tries to underline the expression, with minimal highlighting.

Show matching parens immediately, and "highlight" the whole expression.

#+BEGIN_SRC emacs-lisp
(setq show-paren-delay 0
      show-paren-style 'expression)
#+END_SRC

Make the paren "highlight" the same color as the background, and add underline.  This adds some amount of "highlighting", since the background color overrides the color set by =hl-line-mode=.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'show-paren-match nil
		    :background 'unspecified
		    :underline t)
#+END_SRC

*** Modeline
Funny name for the frame
#+BEGIN_SRC emacs-lisp
(setq frame-title-format "Poor Man's LispM")
#+END_SRC

Show me column number and filesize
#+BEGIN_SRC emacs-lisp
(column-number-mode t)
(size-indication-mode t)
#+END_SRC

*** C-Style
Please use Tabs in C files, I'm BEGGING.  Absolutely ridiculous that there's no simple variable to select Tabs ONLY for indentation.
#+BEGIN_SRC emacs-lisp
(defun c-lineup-arglist-tabs-only (ignored)
  "Line up argument lists by tabs, not spaces. Stolen from https://kernel.org/doc/html/v4.10/process/coding-style.html"
  (let* ((anchor (c-langelem-pos c-syntactic-element))
	 (column (c-langelem-2nd-pos c-syntactic-element))
	 (offset (- (1+ column) anchor))
	 (steps (floor offset c-basic-offset)))
    (* (max steps 1)
       c-basic-offset)))

(add-hook 'c-mode-common-hook
	  (lambda ()
	    ;; Add kernel style
	    (c-add-style
	     "linux-tabs-only"
	     '("linux"
	       (c-offsets-alist
		(arglist-cont-nonempty
		 c-lineup-gcc-asm-reg
		 c-lineup-arglist-tabs-only))))))

(add-hook 'c-mode-hook
	  (lambda ()
	    (setq indent-tabs-mode t)
	    (setq show-trailing-whitespace t)
	    (setq c-backspace-function 'backward-delete-char) ;; don't expand my tabs, just delete them.
	    (c-set-style "linux-tabs-only")))
#+END_SRC

*** Windows-Specific
Use =recycle bin=, DON'T use =AltGr=, and tell emacs where =diff= is.
#+BEGIN_SRC emacs-lisp
(when (equal system-type 'windows-nt)
  (setq delete-by-moving-to-trash t
	ediff-diff-program "\"c:/Program Files/Git/usr/bin/diff.exe\""
	ediff-diff3-program "\"c:/Program Files/Git/usr/bin/diff3.exe\""
	diff-command "\"c:/Program Files/Git/usr/bin/diff.exe\""
	w32-recognize-altgr 'nil))
#+END_SRC

** org configuration
I had this in a use-package declaration, but I find this a little nicer.

*** Basics
Just some basic/misc stuff.  I don't think I've seen too many configs that don't have at least most of these.
#+BEGIN_SRC emacs-lisp
(setq org-M-RET-may-split-line nil
      org-return-follows-link t
      org-agenda-restore-windows-after-quit t
      org-use-fast-todo-selection 'expert
      org-fast-tag-selection-single-key 'expert
      org-agenda-dim-blocked-tasks 'invisible
      org-enforce-todo-dependencies t
      org-enforce-todo-checkbox-dependencies t
      org-agenda-start-on-weekday nil
      org-reverse-note-order t
      org-cycle-separator-lines 0
      org-catch-invisible-edits 'error
      org-deadline-warning-days 30
      org-table-export-default-format "orgtbl-to-csv"
      org-agenda-window-setup 'current-window
      org-link-file-path-type 'absolute
      org-startup-folded t
      org-startup-indented t)
#+END_SRC

*** Bindings

The usual bindings.
#+BEGIN_SRC emacs-lisp
(keymap-global-set "C-c l" 'org-store-link)
(keymap-global-set "C-c a" 'org-agenda)
(keymap-global-set "C-c c" 'org-capture)
(keymap-global-set "C-c b" 'org-switchb)
#+END_SRC

Org special keys - do logical things with =C-a/e/k=, and adjust subtree level when yanking.
#+BEGIN_SRC emacs-lisp
(setq org-special-ctrl-a/e t
      org-special-ctrl-k t
      org-yank-adjusted-subtrees t)
#+END_SRC

*** Directories
Tell org where everything is
#+BEGIN_SRC emacs-lisp
(setq org-directory "~/org"
      org-agenda-files '("~/org")
      org-default-notes-file "~/org/refile.org"
      org-journal-file "~/org/journal.org")
#+END_SRC

Let me refile anywhere, use outline paths, confirm when creating parent nodes.
#+BEGIN_SRC emacs-lisp
(setq org-refile-targets '((nil :maxlevel . 9)
			   (org-agenda-files :maxlevel . 9))
      org-refile-use-outline-path 'file
      org-refile-allow-creating-parent-nodes '(confirm))
#+END_SRC

*** Keywords and Filtering
Set up some more todo keywords
#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords '((sequence "TODO(t)"
				    "WAITING(w@/!)"
				    "IN-PROGRESS(i!)"
				    "APPT(a!)"
				    "|"
				    "DELEGATED(l@)"
				    "DONE(d!/@)"
				    "CANCELLED(c@)")))
#+END_SRC

Set up the agenda view. Access it with =C-c a SPC=.
#+BEGIN_SRC emacs-lisp
(setq org-agenda-custom-commands '((" " "Agenda"
				    ((agenda "" nil)
				     (todo "APPT"
					   ((org-agenda-overriding-header "Appointments")))
				     (tags "need"
					   ((org-agenda-overriding-header "Needed Items")))
				     (tags "REFILE"
					   ((org-agenda-overriding-header "Tasks to Refile")))
				     (tags-todo "TODO=\"IN-PROGRESS\"-REFILE"
					   ((org-agenda-overriding-header "In Progress")))
				     (tags-todo "TODO=\"WAITING\"-REFILE"
					   ((org-agenda-overriding-header "Halted")))
				     (tags-todo "-TODO=\"WAITING\"-TODO=\"IN-PROGRESS\"-REFILE-JOURNAL"
					   ((org-agenda-overriding-header "Filed Tasks")))))))
#+END_SRC

Tag filtering
#+BEGIN_SRC emacs-lisp
(setq org-tag-alist '((:startgroup . nil)
		       ("@errand" . ?e)
		       ("@office" . ?o)
		       ("need" . ?n)
		       (:endgroup . nil)))
#+END_SRC

*** Templates
Capture Templates per my proclivities.
#+BEGIN_SRC emacs-lisp
(setq org-capture-templates '(("n" "Note" entry (file org-default-notes-file) "* %u %?")
			      ("t" "TODO" entry (file org-default-notes-file) "* TODO %?\n%U\n")
			      ("a" "Appointment" entry (file+olp+datetree org-journal-file) "* APPT %?\nSCHEDULED: %t" :time-prompt t)
			      ("j" "Journal" entry (file+olp+datetree org-journal-file) "* %?\n%U\n")))
#+END_SRC

*** Abbreviations + Snippets
Start up =abbrev-mode= for org
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook #'abbrev-mode)
(setq abbrev-file-name (expand-file-name "abbrev_defs" user-emacs-directory)
      save-abbrevs 'silently)
#+END_SRC

**** Skeletons
=Emacs Lisp= source Block
#+BEGIN_SRC emacs-lisp
(define-skeleton skel-org-block-elisp
  "Insert an org emacs lisp block"
  ""
  "#+BEGIN_SRC emacs-lisp\n"
  _ - \n
  "#+END_SRC\n")
#+END_SRC

Facility properties block
#+BEGIN_SRC emacs-lisp
(define-skeleton skel-facility-properties
  "Insert the org title and filetags for a new facility."
  ""
  "#+TITLE: "
  _ - \n
  "#+FILETAGS: customer city state pm sm ee ce aka c#\n\n"
  "* System Notes\n"
  "* PLC [/]\n"
  "* Wonderware [/]\n"
  "* Commissioning [/]\n")
#+END_SRC

Person properties block
#+BEGIN_SRC emacs-lisp
(define-skeleton skel-person-properties
  "Insert the org title and filetags for a person."
  ""
  "#+TITLE: "
  _ - \n
  "#+FILETAGS: company position\n")
#+END_SRC

Workorder properties block
#+BEGIN_SRC emacs-lisp
(define-skeleton skel-workorder-properties
  "Insert the org title and filetags for a workorder"
  ""
  "#+TITLE: Workorder "
  _ - \n
  "#+FILETAGS: workorder customer city state topics\n")
#+END_SRC

Meeting properties block
#+BEGIN_SRC emacs-lisp
(define-skeleton skel-meeting-properties
  "Insert the org title and filetags for a meeting"
  ""
  "#+TITLE: "
  _ -
  " Meeting\n"
  "#+FILETAGS: meeting customer city state attendees topics\n")
#+END_SRC

Bind the snippets (in the =abbrev-file-name= file)
#+BEGIN_SRC emacs-lisp  :tangle ./abbrev_defs
;;-*-coding: utf-8;-*-
(define-abbrev-table 'org-mode-abbrev-table
  '(("selisp" "" skel-org-block-elisp)
    ("sfac" "" skel-facility-properties)
    ("sper" "" skel-person-properties)
    ("swo" "" skel-workorder-properties)
    ("smet" "" skel-meeting-properties)))
#+END_SRC

*** Auto-archive

A function to automatically archive *DONE* items in an org file.  I use this as an after-save-hook header declaration as such:
#+BEGIN_SRC emacs-lisp :tangle no
-*- after-save-hook: (org-auto-archive) -*-
#+END_SRC

Also add that defun to =safe-local-variables= so that emacs will run it.

#+BEGIN_SRC emacs-lisp
(defun org-auto-archive ()
  "Automatically archive completed tasks in an org file.
Intended for use as an after-save-hook."
  (interactive)
  (org-map-entries
   (lambda ()
     (org-archive-subtree)
     (setq org-map-continue-from (org-element-property :begin (org-element-at-point))))
   "TODO=\"DONE\"|TODO=\"CANCELLED\"|TODO=\"DELEGATED\""
   'file)
  (save-buffer))

(setq safe-local-variable-values '((after-save-hook org-auto-archive)))
#+END_SRC

*** Tangling

Some basic settings for dealing with source code in an org file.  Don't make a new window for source-code edits, and keep indentation consistent.
#+BEGIN_SRC emacs-lisp
(setq org-src-window-setup 'current-window
      org-src-preserve-indentation t
      org-src-fontify-natively t)
#+END_SRC

Make a function to tangle this file, and run it on save.
#+BEGIN_SRC emacs-lisp
(defun tangle-init ()
  "Tangle and compile init.org.
Stolen from https://github.com/larstvei/dot-emacs."
  (when (equal (buffer-file-name)
	       (expand-file-name (concat user-emacs-directory "init.org")))
    (let ((prog-mode-hook nil))
      (org-babel-tangle))))

(add-hook 'after-save-hook 'tangle-init)
#+END_SRC

*** Emphasis Regexp
For some reason, the org people decided that =verbatim= doesn't actually mean =verbatim=!  This attempts to fix that.  I found this solution at [[https://emacs.stackexchange.com/questions/13820/inline-verbatim-and-code-with-quotes-in-org-mode][stackexchange]].
#+BEGIN_SRC emacs-lisp
(eval-after-load "org" '(lambda ()
			  (setcar (nthcdr 2 org-emphasis-regexp-components) " \t\r\n,")
			  (org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components)
			  (org-element--set-regexps)))
#+END_SRC

*** File Opening
Don't open links in another window, just use the current one

#+BEGIN_SRC emacs-lisp
(setq org-link-frame-setup '((vm . vm-visit-folder-other-frame)
			     (vm-imap . vm-visit-imap-folder-other-frame)
			     (gnus . org-gnus-no-new-news)
			     (file . find-file)
			     (wl . wl-other-frame)))
#+END_SRC
** Dired configuration
Make dired use the same switches I prefer for =ls=, give me a simpler listing, and default to using its current buffer for visiting a file rather than creating a new one.
#+BEGIN_SRC emacs-lisp
(setq dired-listing-switches "-alv --group-directories-first")

(add-hook 'dired-mode-hook
	  (lambda ()
	    (dired-hide-details-mode t)
	    (keymap-set dired-mode-map
	      "RET" 'dired-find-alternate-file)))
#+END_SRC

** Eshell configuration
Here are the various customizations I have for eshell.

*** Binding to start eshell
#+BEGIN_SRC emacs-lisp
(keymap-global-set "C-c s" 'eshell)
#+END_SRC

*** Make it play nice with corfu

#+BEGIN_SRC emacs-lisp
(add-hook 'eshell-mode-hook (lambda ()
			      (setq-local corfu-auto nil)
			      (corfu-mode)))
#+END_SRC

*** Send on Close-Paren
I wanted something like what the Genera environment has, where putting in a final close-paren will send the command, without having to hit enter.

#+BEGIN_SRC emacs-lisp
(defun eshell-send-on-close-paren ()
  "Makes eshell act somewhat like genera.
Makes a closing paren execute the sexp."
  (interactive)
  (insert-char ?\))
  (when (= 0 (car (syntax-ppss)))
	 (eshell-send-input)))
#+END_SRC

*** Quit or delete-char
I want =C-d= to end the shell if it is on an empty line, otherwise act normally.

#+BEGIN_SRC emacs-lisp
(defun eshell-quit-or-delete-char (arg)
  "Delete char if at one, quit eshell if on empty prompt.
Stolen from https://depp.brause.cc/dotemacs"
  (interactive "p")
  (if (and (eolp) (looking-back eshell-prompt-regexp 0 t))
      (eshell-life-is-too-much) ; https://emacshorrors.com/post/life-is-too-much
    (delete-char arg)))
#+END_SRC

*** Bind the defuns
I have only been able to get these to work when they are within an add-hook lambda.

#+BEGIN_SRC emacs-lisp
(add-hook 'eshell-mode-hook
	  (lambda ()
	    (keymap-set eshell-mode-map ")" 'eshell-send-on-close-paren)
	    (keymap-set eshell-mode-map "C-d" 'eshell-quit-or-delete-char)))
#+END_SRC

** Defuns and Bindings
I have quite a few math and work-related defuns, and fewer editing ones.  Inversely, I have more editing related bindings than work-related ones.  This makes sense, considering my usage patterns.

*** Editing
Most of these are to re-create something from vim/readline/sam/acme.  Some are just helper functions or wrappers.

**** Visiting Files
Bind =find-file-at-point= and =bookmark-jump-other-window=.
#+BEGIN_SRC emacs-lisp
(keymap-global-set "C-x M-f" 'find-file-at-point)
(keymap-global-set "C-x r B" 'bookmark-jump-other-window)
#+END_SRC

**** Undo/redo
I like putting redo on =C-\=. Easier for me to remember than the =C-M-_= default.
#+BEGIN_SRC emacs-lisp
(keymap-global-set "C-\\" 'undo-redo)
#+END_SRC

**** Renaming Files
I took this from [[https://whattheemacsd.com][whattheemacsd.com]].  It is occasionally handy.
#+BEGIN_SRC emacs-lisp
(defun rename-current-buffer-file ()
  "Renames the current buffer and the file it is visiting."
  (interactive)
  (let ((name (buffer-name))
	(filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
	(error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
	(if (get-buffer new-name)
	    (error "A buffer named '%s' already exists!" new-name)
	  (rename-file filename new-name 1)
	  (rename-buffer new-name)
	  (set-visited-file-name new-name)
	  (set-buffer-modified-p nil)
	  (message "File '%s' successfully renamed to '%s'"
		   name (file-name-nondirectory new-name)))))))

(keymap-global-set "C-x C-r" 'rename-current-buffer-file)
#+END_SRC
**** Buffer Handling
Usually I want the buffer menu in the same window I am already on.  Occasionally I want it in a different window.  Bind accordingly.
#+BEGIN_SRC emacs-lisp
(keymap-global-set "C-x C-b" 'buffer-menu)
(keymap-global-set "C-x M-b" 'buffer-menu-other-window)
#+END_SRC

I often want to bring up the scratch buffer in my current window, and sometimes I want only one window that is the scratch buffer.  Emacs 29 added the =scratch-buffer= function, so one less defun needed here.
#+BEGIN_SRC emacs-lisp
(defun scratch-only ()
  "Bring up the scratch buffer as the only visible buffer."
  (interactive)
  (scratch-buffer)
  (delete-other-windows))

(keymap-global-set "<f5>" 'scratch-buffer)
(keymap-global-set "S-<f5>" 'scratch-only)
#+END_SRC

**** Line joining
The =M-^= binding is handy, but usually I want the ed/sam/vi join function, which pulls the next line up into the current line.  I bind this to =M-j=.
#+BEGIN_SRC emacs-lisp
(defun backward-join-line ()
  "A wrapper for join-line to make it go in the right direction."
  (interactive)
  (join-line 0))

(keymap-global-set "M-j" 'backward-join-line)
#+END_SRC

**** Line opening
The default behavior of =open-line= is ridiculous.  It acheives the same function as hitting =RET=.  I don't want to split the current line, I want to OPEN a new one, and usually go to it.  These wrappers remedy that, and allow me to choose whether I want to go to the line or just add it.

#+BEGIN_SRC emacs-lisp
(defun open-line-below (n)
  "Creates a new empty line below the current line and moves to it."
  (interactive "*p")
  (end-of-line)
  (open-line n)
  (call-interactively (next-line))
  (indent-for-tab-command))

(defun open-line-above (n)
  "Creates a new empty line above the current line."
  (interactive "*p")
  (beginning-of-line)
  (open-line n)
  (indent-for-tab-command))
#+END_SRC

I Bind the previous functions to =C-o= and =M-o=.

#+BEGIN_SRC emacs-lisp
(keymap-global-set "C-o" 'open-line-below)
(keymap-global-set "M-o" 'open-line-above)
#+END_SRC

**** Commenting
I stole this directly from [[https://depp.brause.cc/dotemacs][depp.brause.cc/dotemacs]].  Very good, simple solution.
#+BEGIN_SRC emacs-lisp
(defun my-comment-dwim ()
  "Comment region if active, otherwise comment line.
Stolen from https://depp.brause.cc/dotemacs"
  (interactive)
  (if (use-region-p)
      (comment-or-uncomment-region (region-beginning) (region-end))
    (comment-or-uncomment-region (line-beginning-position)
				 (line-end-position))))

(keymap-global-set "M-;" 'my-comment-dwim)
#+END_SRC

**** Killing
Bind =kill-whole-line= to =C-S-K= for something somewhat pnemonic.

#+BEGIN_SRC emacs-lisp
(keymap-global-set "C-S-K" 'kill-whole-line)
#+END_SRC

Bind =C-z= to zap-up-to-char, sice zap-to-char is on =M-z=.

#+BEGIN_SRC emacs-lisp
(keymap-global-set "C-z" 'zap-up-to-char)
#+END_SRC

=C-w= is very much engrained for killing back one word, as is =C-u= for killing back to the beginning of the line.  [[http://unix-kb.cat-v.org/][These have been standard bindings since TENEX...]]

I didn't want to re-bind =C-w= away from =kill-region=, so I made it do both.

#+BEGIN_SRC emacs-lisp
(defun kill-bword-or-region ()
  "Kill region if active, otherwise kill back one word."
  (interactive)
  (if (use-region-p)
      (call-interactively 'kill-region)
    (call-interactively 'backward-kill-word)))

(keymap-global-set "C-w" 'kill-bword-or-region)
#+END_SRC

There is no pre-made function to kill backward to the beginning of line from point, so I made one that passes the correct argument to =kill-line=, and bound it to =C-u=.

#+BEGIN_SRC emacs-lisp
(defun backward-kill-line ()
  "Kill back to beginning of line from point."
  (interactive)
  (kill-line 0))

(keymap-global-set "C-u" 'backward-kill-line)
#+END_SRC

Since =C-u= is =universal-argument=, I put that functionality on =M-'=.

#+BEGIN_SRC emacs-lisp
(keymap-global-set "M-'" 'universal-argument)
#+END_SRC

**** Moving
I want =Home= and =End= to take me to the top and bottom of the file.
#+BEGIN_SRC emacs-lisp
(keymap-global-set "<home>" 'beginning-of-buffer)
(keymap-global-set "<end>" 'end-of-buffer)
#+END_SRC

I have the infamous =smart-beginning-of-line= command here.
#+BEGIN_SRC emacs-lisp
(defun smart-beginning-of-line ()
  "Move point to first non-whitespace character or beginning-of-line.
If point was already at that position, move point to beginning of
line.  Stolen from BrettWitty's dotemacs github repo."
  (interactive "^")
  (let ((oldpos (point)))
    (back-to-indentation)
    (and (= oldpos (point))
	 (beginning-of-line))))
#+END_SRC

I had issues with =smart-beginning-of-line= in =visual-line-mode=, so =smart-beginning-of-visual-line= was created.  It implements part of =back-to-indentation=, but with changes to use =beginning-of-visual-line= instead of =beginning-of-line=.
#+BEGIN_SRC emacs-lisp
(defun smart-beginning-of-visual-line ()
  "Move point to first non-whitespace character or beginning-of-line.
If point was already at that position, move point to beginning of
line. Stolen from BrettWitty's dotemacs github repo.  Modified to
work in visual-line-mode.  Re-implementing `back-to-indentation'
as a visual-line respecter."
  (interactive "^")
  (let ((oldpos (point)))
    (beginning-of-visual-line 1)
    (skip-syntax-forward " " (line-end-position))
    (backward-prefix-chars)
    (and (= oldpos (point))
	 (beginning-of-visual-line))))
#+END_SRC

Remap =move-beginning-of-line=, then remap =beginning-of-visual-line= when going into =visual-line-mode=.  A simple remap would not work for =visual-line-mode=, so I explicitly set =C-a=.
#+BEGIN_SRC emacs-lisp
(global-set-key [remap move-beginning-of-line] 'smart-beginning-of-line)
(add-hook 'visual-line-mode-hook
	  (lambda ()
	    (keymap-global-set "C-a" 'smart-beginning-of-visual-line)))
#+END_SRC

I don't want line numbers in the margin unless I am actively trying to go to a line.  I override =goto-line= with this function, which shows line numbers, asks me where I want to go, and then hides line numbers.
#+BEGIN_SRC emacs-lisp
(defun my-goto-line ()
  "Show line numbers before going to line, then hide them again."
  (interactive)
  (display-line-numbers-mode 1)
  (call-interactively 'goto-line)
  (display-line-numbers-mode -1))

(global-set-key [remap goto-line] 'my-goto-line)
#+END_SRC

I ripped this defun and binding from [[https://github.com/lem-project/lem][lem]].  Can't live without it now.
#+BEGIN_SRC emacs-lisp
(defun other-window-or-split-window (&optional window)
  (interactive)
  (if (= (count-windows) 1)
      (funcall split-window-preferred-function window)
    (other-window 1)))

(keymap-global-set "C-M-o" 'other-window-or-split-window)
#+END_SRC
**** Search and Replace
I made these bindings to put my more-used commands on better keys, and swap them with the less-used ones.
#+BEGIN_SRC emacs-lisp
(keymap-global-set "M-s ." 'isearch-forward-thing-at-point)
(keymap-global-set "M-s M-." 'isearch-forward-symbol-at-point)
(keymap-global-set "M-%" 'replace-regexp)
(keymap-global-set "C-%" 'replace-string)
(keymap-global-set "C-S-R" 'isearch-backward-regexp)
(keymap-global-set "C-S-S" 'isearch-forward-regexp)
#+END_SRC

*** Elisp/Eval bindings
Some old Emacs-like editor (Edwin?) used this binding, so I put it in here.  Less used than the =C-M-x= =eval-defun= binding, but occasionally nice to have.
#+BEGIN_SRC emacs-lisp
(keymap-global-set "C-M-z" 'eval-region)
#+END_SRC

*** *NIX
These defuns are here so that I can use doas/sudo over tramp to edit /local/ files requiring root permissions.  Doas for BSD, Sudo for Linux, nothing for Windows.
#+BEGIN_SRC emacs-lisp
(unless (equal system-type 'windows-nt)
  (if(equal system-type 'berkeley-unix)
      (defun doas ()
	"Use TRAMP to reopen the current buffer as root using doas."
	(interactive)
	(when buffer-file-name
	  (find-alternate-file
	   (concat "/doas:root@localhost:"
		   buffer-file-name))))
    (defun sudo ()
      "Use TRAMP to reopen the current buffer as root using sudo."
      (interactive)
      (when buffer-file-name
	(find-alternate-file
	 (concat "/doas:root@localhost:"
		 buffer-file-name))))))
#+END_SRC

*** Windows
If you've ever had the /pleasure/ of using Aveva (*Formerly WonderWare*) version 2020, you'll understand.
#+BEGIN_SRC emacs-lisp
(when (equal system-type 'windows-nt)
  (defun unfuck-aveva-license ()
    "Remove the offending xml files.
Use this when aveva can't find ass with both hands."
    (interactive)
    (let ((xml1 "c:/ProgramData/AVEVA/Licensing/License API2/Data/LocalAcquireInfo.xml")
	  (xml2 "c:/ProgramData/AVEVA/Licensing/License API2/Data/LocalBackEndAcquireInfo.xml"))
      (when (file-exists-p xml1) (delete-file xml1))
      (when (file-exists-p xml2) (delete-file xml2)))))
#+END_SRC

*** Math
General Math defuns, often used in later defuns.

I'm tired of writing out ='expt=, and I want to use the same notation every other programming language does.
#+BEGIN_SRC emacs-lisp
(defalias '^ 'expt)
#+END_SRC

Define square, cube, and inv for brevity of common usages.
#+BEGIN_SRC emacs-lisp
(defun square (x)
  "Calculate the square of a value."
  (^ x 2))

(defun cube (x)
  "Calculate the cube of a value."
  (^ x 3))

(defun inv (x)
  "Calculate the inverse of a value."
  (/ 1 (float x)))
#+END_SRC

*** Unit Conversions
The rest of the world decided to self-castrate because some French guys told them things Definitely Made More Sense if everything was divisible by 10.  I'm convinced the average Frenchman simply couldn't grasp fractions, and that's why he came up with this crap.  What's 1/3 of a meter?  What's 1/3 of a yard?  And 1/3 of a foot?  How likely are you to need to divide a measurement by 3 when you're building something?  Maybe the [[https://dozenal.org/][Dozenal]] people were right all along.  Anyway, I'm now forced to convert into proper units daily because of this grave error.


#+BEGIN_SRC emacs-lisp
(defun mm->in (mm)
  "Convert milimeters to inches."
  (/ mm 25.4))

(defun in->mm (in)
  "Convert inches to milimeters."
  (* in 25.4))

(defun k->c (tempk)
  "Convert degrees Kelvin to degrees Celsius."
  (- tempk 273.15))

(defun c->k (tempc)
  "Convert degrees Celsius to degrees Kelvin."
  (+ tempc 273.15))

(defun c->f (tempc)
  "Convert degrees Celsius to degrees Fahrenheit."
  (+ (* tempc 1.8) 32.0))

(defun f->c (tempf)
  "Convert degrees Fahrenheit to degrees Celsius."
  (/ (- tempf 32.0) 1.8))

(defun k->f (tempk)
  "Convert degrees Kelvin to degrees Fahrenheit.
Applies `c->f' to `k->c'."
  (c->f (k->c tempk)))

(defun f->k (tempf)
  "Convert degrees Fahrenheit to degrees Kelvin.
Applies `c->k' to `f->c'."
  (c->k (f->c tempf)))
#+END_SRC

*** Electrical
These defuns are all about electronics.  Effective impedance, amps to volts and back again.
#+BEGIN_SRC emacs-lisp
(defun eff-imp (r1 &optional r2)
  "Calculate the effective input impedance, given two resistances.
For use in `amps->volts' and related.  The handling of only one
resistance given is done here, instead of doing it in every
function that uses this."
  (if (eq nil r2)
      r1
    (inv (+ (inv (float r1)) (inv (float r2))))))

(defun amps->volts (amps r1 &optional r2)
  "Calculate the voltage, given amperage and impedance.
Multiplies the amperage by the effective impedance calculated
with `eff-imp'."
  (* amps (eff-imp r1 r2)))

(defun volts->amps (volts r1 &optional r2)
  "Calculate the amperage, given voltage and impedance.
Divides the voltage by the effective impedance calculated with
`eff-imp'."
  (/ volts (eff-imp r1 r2)))
#+END_SRC

*** PLC
The nitty-gritty.  These defuns build on the previous ones to help me do various calculations related to analog signals and how they interact with [[https://en.wikipedia.org/wiki/Programmable_logic_controller][PLCs]], also called PACs.  Counts, volts, amps, bit-resolutions, and relating them to each other.
#+BEGIN_SRC emacs-lisp
(defun max-counts (resolution)
  "Calculate the max count for a PLC analog, given card's bit-resolution."
  (- (^ 2 resolution) 1))

(defun volts->counts (vin vmax resolution)
  "Convert a voltage signal to a PLC count.
Calculates a ratio of vin/vmax, then scales by `max-counts'."
  (* (/ (float vin) vmax) (max-counts resolution)))

(defun counts->volts (cin vmax resolution)
  "Convert a PLC count to a voltage.
Calculates a ratio of cin/`max-counts', then multiplies by vmax."
  (* (/ (float cin) (max-counts resolution)) vmax))

(defun amps->counts (amps vmax resolution r1 &optional r2)
  "Convert a current signal to PLC Counts.
Converts the amperage to a voltage using `amps->volts' (with r1
and optional r2), then applies `volts->counts' to the resulting
voltage, vmax, and resolution."
  (volts->counts (amps->volts amps r1 r2) vmax resolution))

(defun count-range (type upper lower vmax resolution &optional r1 r2)
  "Given an upper and lower signal, return the list of upper and lower PLC counts.
Type takes either a v or an i, corresponding to a voltage or
current signal.  With a current signal, use r1 and maybe r2 to
calculate `amps->counts'.  Otherwise ignore r1/r2 and calculate
`volts->counts'."
  (cond ((or (equal 'v type)
	     (equal 'V type))
	 (list (volts->counts upper vmax resolution)
	       (volts->counts lower vmax resolution)))
	((or (equal 'i type)
	     (equal 'I type))
	 (list (amps->counts upper vmax resolution r1 r2)
	       (amps->counts lower vmax resolution r1 r2)))))

(defun scaleval (pmax pmin emax emin &optional ai)
  "Calculate the slope and offset given PLC Max/Min and Eng. Max/Min.
With optional argument `ai', also calculate a final scaled value from an input."
  (let* ((div (/ (- pmax pmin) (- (float emax) (float emin))))
	 (ofst (- emin (/ pmin div))))
    (if (eq nil ai)
	(list div ofst)
      (list div ofst (+ ofst (/ ai div))))))
#+END_SRC

*** Refrigeration
More nitty-gritty.  These are for calculating specific refrigeration-related things.  Somewhat specialized.
#+BEGIN_SRC emacs-lisp
(defun cfm-circ (fpm radius)
  "Calculate the CFM of a circular duct.
Inputs are feet/minute and radius (in)."
  (list (* float-pi fpm (square (/ radius 12.0)))))

(defun cfm-rect (fpm width height)
  "Calculate the CFM of a rectangular duct.
Inputs are feet/minute, width (in) and height (in)."
  (list (* fpm (/ width 12.0) (/ height 12.0))))

(defun gn-water-per-lb (temp humidity)
  "Calculate the grains of water per lb of air.
Inputs are temp (F) and humidity (%).  Returns a list of
Saturated Water Pressure, Humidity Ratio, and Grains of water per
lb of air."
  (let* ((sat-water-press (+ .0182795
			     (* temp .001029904)
			     (* (square temp) 0.00002579408)
			     (* (cube temp) (* 2.400493 (^ 10 -7)))
			     (* (^ temp 4) (* 8.100939 (^ 10 -10)))
			     (* (^ temp 5) (* 3.256805 (^ 10 -11)))
			     (* (^ temp 6) (* -1.001922 (^ 10 -13)))
			     (* (^ temp 7) (* 2.44161 (^ 10 -16)))))
	 (hum-press (* (/ humidity 100.0) sat-water-press))
	 (hum-ratio (/ (* hum-press 0.62198) (- 14.7 hum-press)))
	 (gns-water-lb-air (* hum-ratio 7000)))
    (list sat-water-press hum-ratio gns-water-lb-air)))
#+END_SRC



** Customize system
I do not use the customize system.  I don't want to see it if I don't have to.

#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(when (not (file-exists-p custom-file))
  (make-empty-file custom-file))

(load custom-file)
#+END_SRC

** Footer

#+BEGIN_SRC emacs-lisp
;;; hic terminatur init.el
#+END_SRC
